/*

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

例如，121 是回文，而 123 不是。


示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。


提示：

-231 <= x <= 231 - 1


进阶：你能不将整数转为字符串来解决这个问题吗？

*/

/*

回文 就是 正着反着看都是一样的

1. 按照字符串的回文来做, 即转换字符串
   - 中间遍历
   - 调用api split().reverse().join()

2. 不转换成字符串, 我们比对的是 首位与末位

假设 x 是一个四位数

怎么获取首位 x / 1000
怎么获取末尾 x % 10

如果相等则继续

x % 1000 是不是 就是去除原来的首位, 再 / 10 是不是就去除原来的末位

然后我们是不是需要去寻找 这个 1000 
4 位数的时候是 1000
3 位数的时候是 100

所以我们需要去确定位数?

lg100  => 2
lg1000 => 3

是不是就得到了


*/
export function isPalindrome(x: number): boolean {
  // 小于10, 比如 0-9只有一位 是可以直接排除的
  // 然后需要排除负数, 负数一定不是回文
  if (x < 10) {
    return x >= 0;
  }
  let n = 10 ** Math.floor(Math.log10(x));
  while (x > 0 && n > 0) {
    if (Math.floor(x / n) !== x % 10) {
      return false;
    }
    x = Math.floor((x % n) / 10);
    n /= 100;
  }
  return true;
}

/*

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



示例 1：

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：

输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
示例 3：

输入：digits = [0]
输出：[1]


提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9

*/

export function plusOne(digits: number[]): number[] {
  const r: number[] = digits.slice();
  let i = r.length - 1;
  while (i >= 0) {
    if (r[i] === 9) {
      r[i] = 0;
    } else {
      r[i]++;
      return r;
    }
    i--;
  }
  return [1, ...r];
}

/*

给定一个整数 n ，返回 n! 结果中尾随零的数量。

提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1



示例 1：

输入：n = 3
输出：0
解释：3! = 6 ，不含尾随 0
示例 2：

输入：n = 5
输出：1
解释：5! = 120 ，有一个尾随 0
示例 3：

输入：n = 0
输出：0


提示：

0 <= n <= 104


进阶：你可以设计并实现对数时间复杂度的算法来解决此问题吗？

*/

/*

阶乘怎么才回产生 0, 

首先想到的是 10, 20, 30, 这种
然后想到 2 * 5, 4 * 5,

所以只要 2 5 成对 就会出现 0, 所以我们现在需要是 以 2 为标准还是 5 为标准

举个例子 9! 的阶乘

1 * 2 * 3 * 4 * 5 * 6 * 7 * 8 * 9 = 362880

有多少个 2 

2 
4 = 2 * 2
6 = 2 * 3
8 = 2 * 4

可以理解为 4 个 2 
但是只有一个 5

那再举个例子 10! = 362880

也就是 5 个2 和 2个5, 所以我们以 5 为标准就行了

*/

export function trailingZeroes(n: number): number {
  let r = 0;
  while (n !== 0) {
    n = Math.floor(n / 5);
    r += n;
  }
  return r;
}

/*

给你一个非负整数 x ，计算并返回 x 的 算术平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。



示例 1：

输入：x = 4
输出：2
示例 2：

输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。


提示：

0 <= x <= 231 - 1

*/

/*

不借助 Math.sqrt

也就是我们找到 某个数的 平方最接近 x 就行了

*/

export function mySqrt(x: number): number {
  // 0 和 1 直接返回就好
  if (x < 2) {
    return x;
  }
  let start = 0;
  let end = x;
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    if (mid * mid < x) {
      start = mid + 1;
    } else if (mid * mid > x) {
      end = mid - 1;
    } else {
      return mid;
    }
  }
  return end;
}
