/*

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

例如，121 是回文，而 123 不是。


示例 1：

输入：x = 121
输出：true
示例 2：

输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
示例 3：

输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。


提示：

-231 <= x <= 231 - 1


进阶：你能不将整数转为字符串来解决这个问题吗？

*/

/*

回文 就是 正着反着看都是一样的

1. 按照字符串的回文来做, 即转换字符串
   - 中间遍历
   - 调用api split().reverse().join()

2. 不转换成字符串, 我们比对的是 首位与末位

假设 x 是一个四位数

怎么获取首位 x / 1000
怎么获取末尾 x % 10

如果相等则继续

x % 1000 是不是 就是去除原来的首位, 再 / 10 是不是就去除原来的末位

然后我们是不是需要去寻找 这个 1000 
4 位数的时候是 1000
3 位数的时候是 100

所以我们需要去确定位数?

lg100  => 2
lg1000 => 3

是不是就得到了


*/
export function isPalindrome(x: number): boolean {
  // 小于10, 比如 0-9只有一位 是可以直接排除的
  // 然后需要排除负数, 负数一定不是回文
  if (x < 10) {
    return x >= 0;
  }
  let n = 10 ** Math.floor(Math.log10(x));
  while (x > 0 && n > 0) {
    if (Math.floor(x / n) !== x % 10) {
      return false;
    }
    x = Math.floor((x % n) / 10);
    n /= 100;
  }
  return true;
}

/*

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。



示例 1：

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
示例 2：

输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
示例 3：

输入：digits = [0]
输出：[1]


提示：

1 <= digits.length <= 100
0 <= digits[i] <= 9

*/

export function plusOne(digits: number[]): number[] {
  const r: number[] = digits.slice();
  let i = r.length - 1;
  while (i >= 0) {
    if (r[i] === 9) {
      r[i] = 0;
    } else {
      r[i]++;
      return r;
    }
    i--;
  }
  return [1, ...r];
}
