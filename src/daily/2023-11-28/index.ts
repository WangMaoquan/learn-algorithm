/*

颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


示例 1：

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。


提示：

输入是一个长度为 32 的二进制字符串


进阶: 如果多次调用这个函数，你将如何优化你的算法？

*/

/*
题目的意思就是 给你一个整数, 你转换成一个 长度为32 的二进制字符串,  颠倒的就是把 reverse , 最后返还

Number.toString(2) 转换成 二进制字符 

ParseInt(targetStr, 2) 将二进制字符串 转变成 十进制

*/
export function reverseBits1(n: number): number {
  return parseInt(
    n.toString(2).padStart(32, '0').split('').reverse().join(''),
    2,
  );
}

/*

既然是二进制, 二进制怎么移位的呢?  << / >>  >>> 

<< 左移

>> 右移

>>> 无符号右移 会忽略符号位

-5 二进制表示 11111111111111111111111111111011

然后 -5 >> 2  11111111111111111111111111111110

符号位是没有变的

然而 -5 >>> 2 00111111111111111111111111111110

忽略了符号位

然后我们开始取值

我们应该先从 31 开始取

如果取的是1 怎么保证 赋值的 1 呢? 很明显 & 1

然后怎么保证 r 上原来的 1不变呢?  很明显 | 1


*/
export function reverseBits(n: number): number {
  let r = 0;
  for (let i = 0; i < 32; i++) {
    r |= (n & 1) << (31 - i);
    n >>>= 1;
  }
  // >>> 0 去掉无符号位
  return r >>> 0;
}
