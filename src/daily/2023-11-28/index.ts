/*

颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


示例 1：

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。


提示：

输入是一个长度为 32 的二进制字符串


进阶: 如果多次调用这个函数，你将如何优化你的算法？

*/

/*
题目的意思就是 给你一个整数, 你转换成一个 长度为32 的二进制字符串,  颠倒的就是把 reverse , 最后返还

Number.toString(2) 转换成 二进制字符 

ParseInt(targetStr, 2) 将二进制字符串 转变成 十进制

*/
export function reverseBits1(n: number): number {
  return parseInt(
    n.toString(2).padStart(32, '0').split('').reverse().join(''),
    2,
  );
}

/*

既然是二进制, 二进制怎么移位的呢?  << / >>  >>> 

<< 左移

>> 右移

>>> 无符号右移 会忽略符号位

-5 二进制表示 11111111111111111111111111111011

然后 -5 >> 2  11111111111111111111111111111110

符号位是没有变的

然而 -5 >>> 2 00111111111111111111111111111110

忽略了符号位

然后我们开始取值

我们应该先从 31 开始取

如果取的是1 怎么保证 赋值的 1 呢? 很明显 & 1

然后怎么保证 r 上原来的 1不变呢?  很明显 | 1


*/
export function reverseBits(n: number): number {
  let r = 0;
  for (let i = 0; i < 32; i++) {
    r |= (n & 1) << (31 - i);
    n >>>= 1;
  }
  // >>> 0 去掉无符号位
  return r >>> 0;
}

/*

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。



提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。


示例 1：

输入：n = 00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：n = 00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：

输入：n = 11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。


提示：

输入必须是长度为 32 的 二进制串 。


进阶：

如果多次调用这个函数，你将如何优化你的算法？

*/

/*

最简单的其实就是 转成字符串判断 '1' 的数量

*/

export function hammingWeight(n: number): number {
  let r = 0;
  const bStr = n.toString(2);
  for (let i = 0; i < bStr.length; i++) {
    if (bStr[i] === '1') {
      r++;
    }
  }
  return r;
}

/*

我们知道 & 能保存 1, 其实也就是 nums1 & nums2 的结果大于 0 我们就能保证 对位存在1

那么我们怎么去构造一个 nums2 呢? 1 << i 就行了

*/

export function hammingWeight1(n: number): number {
  let r = 0;
  for (let i = 0; i < 32; i++) {
    if (n & (1 << i)) {
      r++;
    }
  }
  return r;
}
