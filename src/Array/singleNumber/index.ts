/**
 * 题目:
 * 给你一个 非空 整数数组 nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素
 *
 * 你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间
 *
 * 示例 1：
 * 输入：nums = [2,2,1]
 * 输出：1
 *
 * 示例 2:
 * 输入：nums = [4,1,2,1,2]
 * 输出：4
 *
 * 示例 3:
 * 输入：nums = [1]
 * 输出：1
 *
 *
 * 提示
 * 1 <= nums.length <= 3 * Math.pow(10, 3)
 * -3 * Math.pow(10, 3) <= nums[i] <= 3 * Math.pow(10, 3)
 * 除了某个元素只出现一次以外，其余每个元素均出现两次
 */

/**
 * 如果 没有 算法 只使用 常量额外空间 这个限制, 方法应该很多
 *
 * 单个常量的变化 我们可以想到 ++ -- | ^ & ~ 这些操作
 *
 * ++ -- 可以先排除 我们可以看看位运算, 然后我们假设 数组是 [1, 2, 2]
 *
 * & 按位与 同为1才为1
 * | 按位或 有1才1
 * ~ 按位非  反转位
 * ^ 按位异或 不同才为1
 *
 * 其中 按位异或 有 相同的数字按位异或 为 0, 0 与任何异或为其本身
 * 前面半句 就是 2 的 整数倍次数 异或下来都是 0, 刚好满足本题
 */

export function singleNumber(nums: number[]): number {
  let r = 0;
  for (let i = 0; i < nums.length; i++) {
    r ^= nums[i];
  }
  return r;
}
